---
title: "Gene expression of L. plantarum WCFS1"
author: "Ivar van den Akker, Herke Schuffel, Yuri Wit en Peter Cserei"
date: "11/24/2020"
output:
  word_document:
    toc: yes
    toc_depth: '4'
  pdf_document:
    toc: yes
    toc_depth: 4
  html_document:
    df_print: paged
    toc: yes
    toc_depth: '4'
toctitle: Inhoudsopgave
---
## Samenvatting

## Inleiding
Doel: When L. plantarum is grown on a ribose-rich medium genes are upregulated that are required for metabolizing ribose.

## Materiaal en Methode
Dit R-script analyseert de expressie van genen van L. plantarum varianten: WCFS1 en NC8. Deze twee bacterien zijn gegroeid op verschillende bodems namelijk glucose (glc) en ribose (rib).

## Resultaten
#### Library importeren
Importeren van library's die nodig zijn voor het functioneren van onderstaande script.

```{r limma edgeR}
library(limma)
library(edgeR)
library(dplyr)
library(xlsx)
library(factoextra)
library(cluster)
library(latexpdf)
library(tinytex)
library(pathview)
```

#### Bestand inladen
Het eerste variabel slaat de locatie van het bestand op. Vanzelfsprekend wordt ook de naam van het nodige bestand in een variabel opgeslagen.

De read.delim functie wordt over het algemeen gebruikt om tekstbestanden in te lezen waarbij data georganiseerd is in een data matrix layout. Binnen deze functie zijn de bovenste twee variabelen aan elkaar te plakken met paste0. 

Daarbij wordt het kolom dat zorgt voor het oplopende nummering van rijen omgezet naar de ID kolom. Dit is gedaan om te voorkomen dat er verwarring ontstaat. De nummering van R zou namelijk niet overeen komen met de ID's van de ingeladen data. Dit is van belang voor eventuele latere annotatie.

```{r}
fDir <- "./"
fName <- "RNA-Seq-counts.txt"
cnts <- read.delim(paste0(fDir,fName), comment.char="#")
row.names(cnts) <- cnts[,"ID"]

f2Name <- "WCFS1_anno.txt"
annotation <- read.delim(paste0(fDir,f2Name), comment.char = "#")
row.names(annotation) <- annotation[,row_number(0)]
```

#### DGE list maken
EdgeR slaat data op in een list-based data object genaamd een DGEList. Dit type object is gemakkelijk te gebruiken binnen R aangezien een DGEList gemanipuleerd kan worden zoals ieder ander lijst in R. Daarbij maakt een DGElist het mogelijk om berekeningen en statistiek toe te passen op de data. In het script worden de counts in de kolommen 2 t/m 9 gegroepeerd met de acht aangemaakte labels.

```{r}
label <- c("WCFS1.glc",  "WCFS1.glc",	"WCFS1.rib",	"WCFS1.rib",	"NC8.glc",	"NC8.glc",	"NC8.rib",	"NC8.rib")
group <- factor(label)
y <- DGEList(counts=cnts[,2:9],group=group)
```

#### Data normaliseren
Normalisatie wordt toegepast om biologische variatie uit de data te halen, zodat vervolgens de verschillende datasets met elkaar vergeleken kunnen worden. In R wordt dit gedaan door norm factors te berekenen. De TMM (trimmed mean of M-values) methode verwijdert eerst de laagste en hoogste waarden en bepaalt daarna het gemiddelde van de rest van de genen.

Hieronder zijn de norm factors weergegeven, zonder calcNormFactors toe te passen zou deze voor alle rijen 1 zijn. De data is genormaliseerd nadat het met de norm factors vermenigvuldigd is. Dit proces gaat automatisch in R na het veranderen van de norm factors.

```{r}
y <- calcNormFactors(y, method="TMM" )
print(y$samples)
```

#### Filteren op low counts
Deze functie zorgt ervoor dat genen geselecteert worden die niet significant genoeg zijn voor de dataset. Aangezien de dataset waarmee gewerkt wordt al een keer is gefilterd, resulteert de functie "filter by expression" maar in een hele kleine hoeveelheid genen, namelijk 20 stuks.

```{r}
keep <- filterByExpr(y)
y <- y[keep,]
```

#### Design matrix maken
Een design matrix geeft aan hoe de samples gegroepeerd zijn in de experimenten. In dit geval is te zien dat glucose 1 en 2 gekoppeld zijn aan glucose van het desbetreffende bacterie. Hetzelfde geldt voor ribose. 

```{r}
design <- model.matrix(~0+group, data=y$samples)
colnames(design) <- levels(y$samples$group)
print(design)
```

#### Despersie berekenen
Er zijn twee verschillende manieren getest om de dispersie te berekenen. 

```{r}
y <- estimateDisp(y, design)

f <- estimateGLMCommonDisp(y,design)
f <- estimateGLMTrendedDisp(y,design, method="power")
f <- estimateGLMTagwiseDisp(y,design)
```

#### Fit data
De glmFit functie maakt een DGEGLM object aan waarin allerlei data wordt verwerkt en berekent daarbij onder andere de p-values en fold-changes.

```{r}
fit <- glmFit(y,design)
```

#### Determine fold changes

```{r}
WCFSglcrib <- makeContrasts(exp.r=WCFS1.glc-WCFS1.rib, levels=design)
WCFSglcribfit <- glmLRT(fit, contrast=WCFSglcrib)
NC8glcrib <- makeContrasts(exp.r=NC8.glc-NC8.rib, levels=design)
NC8glcribfit <- glmLRT(fit, contrast=NC8glcrib)
```

#### Print top tags
WCFS glucose vs WCFS ribose

```{r}
WCFSglcribres<-topTags(WCFSglcribfit, n=nrow(WCFSglcribfit))
```

NC8 glucose vs NC8 ribose
```{r}
NC8glcribres<-topTags(NC8glcribfit, n=nrow(NC8glcribfit))
```
#### Cluster genes using hierarchal clustering

```{r}
x <- t(y$counts)
x <- dist(x, method = "euclidean")
x <- hclust(x, method = "average")
plot(x)
```

#### PCA plot
De PCA plot (principal component analysis) comprimeert de datasets door de data zo veel mogelijk om te zetten naar de 1ste dimensies. Het verminderen van dimensies van de variatie in de samples maakt het mogelijk om de ze gemakkelijk te visualiseren en met elkaar te vergelijken. De X en Y as geven de fold-change in de log2 schaal weer. De X-as verklaart de hoogste variatie, in dit geval laat het zien dat het verschil in fold-change tussen WCFS1.glucose en WCFS1.ribose zeer groot is. Daarbij valt ook op dat de groepen die in de design matrix gemaakt zijn weinig variatie met elkaar hebben.

```{r}
plotMDS(y)
```

#### Dispersie plot
De dispersie plot laat de spreiding van de data zien. Dit zegt iets over hoe goed de verschillende samples met elkaar te vergelijken zijn. Op de X-as staat de CPM (counts per million) op de log schaal en Y-as de dispersie. De rode lijn is de common, het ideale scenario. De blauwe lijn laat de afwijking zien van variatie van de verschillende samples. Hier is te zien dat de trendlijn redelijk overeen komt met de common lijn. 

```{r}
plotBCV(y)
plotBCV(f)
```

#### Filteren
Om genen te selecteren die voor ons onderzoek van toepassing zijn hebben we cut of values ingesteld voor de p-value en de fold changes. Voor de p-value is er gekozen om deze onder de 0.05 te houden en de fold changes moeten hoger zijn dan 1 of lager zijn dan -1.
WCFS glucose vs WCFS ribose

```{r}
WCFSfinal <- filter(WCFSglcribres$table,  WCFSglcribres$table$FDR<0.05 &(WCFSglcribres$table$logFC>1|WCFSglcribres$table$logFC<(-1)))
```

NC8 glucose vs NC8 ribose

```{r}
NC8final <- filter(NC8glcribres$table,  NC8glcribres$table$FDR<0.05 &(NC8glcribres$table$logFC>1|NC8glcribres$table$logFC<(-1)))
```

Annotatie toevoegen aan de genen die zijn gefiltered en van hoog naar laag sorteren

```{r}
WCFS1_sig <- cbind(WCFSfinal, annotation[rownames(WCFSfinal),])
NC8_sig <- cbind(NC8final, annotation[rownames(NC8final),])
WCFS1_sorted <- WCFS1_sig[order(WCFS1_sig[, "logFC"], decreasing = TRUE, na.last = FALSE), ,drop=FALSE]
NC8_sorted <- NC8_sig[order(NC8_sig[, "logFC"], decreasing = TRUE, na.last = FALSE), ,drop=FALSE]
```

Excel file maken met de data en annotaties

```{r}
#write.xlsx(WCFS1_sorted, file = "Merged_Genes.xlsx", sheetName = "WCFS1_data", 
#  col.names = TRUE, row.names = TRUE, append = FALSE)
#write.xlsx(NC8_sorted, file = "Merged_Genes.xlsx", sheetName = "NC8_data", 
#  col.names = TRUE, row.names = TRUE, append = TRUE)
```

#### Heat Map
```{r}
# Sorry ik was verkeerde aan het doen mischien heb je er wel wat aan
HMNC8 = data.matrix(NC8final %>% select(-(LR:FDR)))
heatmap(HMNC8)
```

#### KEGG Mapper
```{r}
#Define pathway to be used (found on KEGG db)
glycolysispathway <- "lpl00010"
pentosephyosphatepathway <- "lpl00030"
#Load selected genes
WCFS1genes <- read.xlsx("Merged_Genes.xlsx", 1)
NC8genes <- read.xlsx("Merged_Genes.xlsx", 2)
#Seperate logFC of selected genes
WCFS1logFC <- WCFS1genes$logFC
NC8logFC <- NC8genes$logFC
#Set names of the data
names(WCFS1logFC) <- WCFS1genes$NA.
names(NC8logFC) <- NC8genes$NA.
#Generate pathviews
WCFS1.out <- pathview(gene.data = WCFS1logFC, species = "lpl", pathway = glycolysispathway, gene.idtype = "KEGG")
file.copy("lpl00010.pathview.png", "WCFS1.lpl00010.pathview.png", overwrite = TRUE)
NC8.out <- pathview(gene.data = NC8logFC, species = "lpl", pathway = glycolysispathway, gene.idtype = "KEGG")
file.copy("lpl00010.pathview.png", "NC8.lpl00010.pathview.png", overwrite = TRUE)

WCFS1.out <- pathview(gene.data = WCFS1logFC, species = "lpl", pathway = pentosephyosphatepathway, gene.idtype = "KEGG")
file.copy("lpl00030.pathview.png", "WCFS1.lpl00030.pathview.png", overwrite = TRUE)
NC8.out <- pathview(gene.data = NC8logFC, species = "lpl", pathway = pentosephyosphatepathway, gene.idtype = "KEGG")
file.copy("lpl00030.pathview.png", "NC8.lpl00030.pathview.png", overwrite = TRUE)
```

#### K-means
```{r}
km <- kmeans((WCFSfinal %>% select(-(logCPM:FDR))), centers = 2)
fviz_cluster(km, data = (WCFSfinal %>% select(-(LR:FDR))))
km <- kmeans((NC8final %>% select(-(logCPM:FDR))), centers = 2)
fviz_cluster(km, data = (NC8final %>% select(-(LR:FDR))))
```
## Discussie


K-means cluster is niet consistent boven de 3 cluster bij dit onderzoek. Als het 4 of hoger word dan maakt het elke keer andere clusters omdat k-means clustering elke keer een random gekozen punt neemt en dan kijk welke punten het dichtst bij liggen. Dan neemt die het gemiddelde daarvan en kijkt die nog maals. Deze 2 stappen herhaald die een paar keer en dan kiest die de beste uit.

## Conclusie
In dit onderzoek is gekeken of L. plantarum dat op een ribose rijk medium is gegroeid upgereguleerde genen heeft die nodig zijn voor de metabolise van ribose. Uit dit onderzoek is ook gebleken dat de genen van L.plantarum die nodig zijn voor de metabolise van ribose upgereguleerd zijn op een ribose bodem in tegenstelling tot een glucose bodem. In vervolg onderzoek zou gekeken kunnen worden naar anderen vatianten van L.plantarum. Ook zou dit onderzoek uitgevoerd kunnen worden met nog strengere eisen zoals hogere filter values of lagere p-value.